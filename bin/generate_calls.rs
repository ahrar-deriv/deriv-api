use convert_case::{Case, Casing};
use handlebars::Handlebars;
use log::{debug, info};
use serde_json::{json, Value};
use std::fs;
use std::path::Path;

const DEFAULT_SCHEMA_PATH: &str = "./deriv-api-docs/config/v3/";
const API_CALLS_FILE: &str = "./src/api/calls.rs";
const SUBSCRIPTION_CALLS_FILE: &str = "./src/api/subscription_calls.rs";

// Templates for code generation
const HEADER_TEMPLATE: &str = r#"
// Code generated by generate_calls.rs, DO NOT EDIT.
use crate::client::DerivClient;
use crate::error::Result;
use deriv_api_schema::*;
use crate::subscription::Subscription;
"#;

const API_CALL_TEMPLATE: &str = r#"
#[cfg(feature = "{{feature_name}}")]
/// {{description}}
pub async fn {{fn_name}}(&self, request: deriv_api_schema::{{request_type}}) -> Result<deriv_api_schema::{{response_type}}> {
    self.send_request(&request).await
}
"#;

const SUBSCRIPTION_CALL_TEMPLATE: &str = r#"
#[cfg(feature = "{{feature_name}}")]
/// Subscribe to {{description}}
pub async fn subscribe_{{fn_name}}(&self, request: deriv_api_schema::{{request_type}}) -> Result<(deriv_api_schema::{{response_type}}, Subscription<deriv_api_schema::{{stream_type}}>)> {
    let mut request = request;
    request.subscribe = Some(1);
    let initial_response = self.send_request(&request).await?;
    // Subscription setup will be implemented here
    unimplemented!("Subscription not implemented yet")
}
"#;

#[derive(Debug)]
struct ApiEndpoint {
    name: String,
    description: String,
    has_subscription: bool,
    request_type: String,
    response_type: String,
    stream_type: Option<String>,
    feature_name: String,
}

#[derive(Debug)]
enum GeneratorError {
    Io(std::io::Error),
    Json(serde_json::Error),
    Template(handlebars::TemplateError),
    Render(handlebars::RenderError),
}

impl From<std::io::Error> for GeneratorError {
    fn from(err: std::io::Error) -> Self {
        GeneratorError::Io(err)
    }
}

impl From<serde_json::Error> for GeneratorError {
    fn from(err: serde_json::Error) -> Self {
        GeneratorError::Json(err)
    }
}

impl From<handlebars::TemplateError> for GeneratorError {
    fn from(err: handlebars::TemplateError) -> Self {
        GeneratorError::Template(err)
    }
}

impl From<handlebars::RenderError> for GeneratorError {
    fn from(err: handlebars::RenderError) -> Self {
        GeneratorError::Render(err)
    }
}

fn main() -> Result<(), GeneratorError> {
    env_logger::init();
    info!("Starting API calls generation");

    let schema_path =
        std::env::var("SCHEMA_PATH").unwrap_or_else(|_| DEFAULT_SCHEMA_PATH.to_string());

    // Read and parse all schema files
    info!("Reading schema files from {}", schema_path);
    let endpoints = read_schema_files(&schema_path)?;

    // Generate API calls
    info!("Generating API calls");
    generate_api_calls(&endpoints)?;

    // Generate subscription calls
    info!("Generating subscription calls");
    generate_subscription_calls(&endpoints)?;

    info!("API call generation completed successfully");
    Ok(())
}

fn read_schema_files(schema_path: &str) -> Result<Vec<ApiEndpoint>, GeneratorError> {
    let mut endpoints = Vec::new();
    let path = Path::new(schema_path);

    for entry in fs::read_dir(path)? {
        let entry = entry?;
        let path = entry.path();

        if path.is_dir() {
            let name = path
                .file_name()
                .and_then(|n| n.to_str())
                .unwrap_or("")
                .to_string();

            // Skip if it's not a valid endpoint directory
            if name.is_empty() || name.starts_with('.') {
                continue;
            }

            let send_path = path.join("send.json");
            let receive_path = path.join("receive.json");

            if !send_path.exists() || !receive_path.exists() {
                debug!("Skipping {}: missing schema files", name);
                continue;
            }

            // Try reading and parsing the schema files
            match (read_json_file(&send_path), read_json_file(&receive_path)) {
                (Ok(send_schema), Ok(receive_schema)) => {
                    match parse_endpoint(&name, &send_schema, &receive_schema) {
                        Ok(endpoint) => {
                            debug!("Adding endpoint: {}", name);
                            endpoints.push(endpoint);
                        }
                        Err(e) => {
                            debug!("Failed to parse endpoint {}: {:?}", name, e);
                            // Continue with other endpoints
                            continue;
                        }
                    }
                }
                _ => {
                    debug!("Failed to read schema files for {}", name);
                    continue;
                }
            }
        }
    }

    Ok(endpoints)
}

fn read_json_file(path: &Path) -> Result<Value, GeneratorError> {
    let content = fs::read_to_string(path)?;
    Ok(serde_json::from_str(&content)?)
}

fn parse_endpoint(
    name: &str,
    send: &Value,
    _receive: &Value,
) -> Result<ApiEndpoint, GeneratorError> {
    let description = send["description"].as_str().unwrap_or("").to_string();

    let has_subscription = send["properties"]
        .as_object()
        .and_then(|props| props.get("subscribe"))
        .is_some();

    let request_type = format!("{}Request", name.to_case(Case::Pascal));
    let response_type = format!("{}Response", name.to_case(Case::Pascal));
    let stream_type = if has_subscription {
        Some(response_type.clone())
    } else {
        None
    };
    let feature_name = name.to_case(Case::Snake);

    Ok(ApiEndpoint {
        name: name.to_string(),
        description,
        has_subscription,
        request_type,
        response_type,
        stream_type,
        feature_name,
    })
}

fn generate_api_calls(endpoints: &[ApiEndpoint]) -> Result<(), GeneratorError> {
    let mut handlebars = Handlebars::new();
    handlebars.register_template_string("api_call", API_CALL_TEMPLATE)?;

    let mut output = String::from(HEADER_TEMPLATE);

    for endpoint in endpoints {
        let data = json!({
            "fn_name": endpoint.name.to_case(Case::Snake),
            "description": endpoint.description,
            "request_type": endpoint.request_type,
            "response_type": endpoint.response_type,
            "feature_name": endpoint.feature_name,
        });

        output.push_str(&handlebars.render("api_call", &data)?);
    }

    fs::write(API_CALLS_FILE, output)?;

    Ok(())
}

fn generate_subscription_calls(endpoints: &[ApiEndpoint]) -> Result<(), GeneratorError> {
    let mut handlebars = Handlebars::new();
    handlebars.register_template_string("subscription_call", SUBSCRIPTION_CALL_TEMPLATE)?;

    let mut output = String::from(HEADER_TEMPLATE);

    for endpoint in endpoints {
        if !endpoint.has_subscription {
            continue;
        }

        let data = json!({
            "fn_name": endpoint.name.to_case(Case::Snake),
            "description": endpoint.description,
            "request_type": endpoint.request_type,
            "response_type": endpoint.response_type,
            "stream_type": endpoint.stream_type.as_ref().unwrap_or(&endpoint.response_type),
        });

        output.push_str(&handlebars.render("subscription_call", &data)?);
    }

    fs::write(SUBSCRIPTION_CALLS_FILE, output)?;

    Ok(())
}
